## Advent of Code 2025 Day 1 Walkthrough

It's that time of year again, time for Advent of Code. If you've never heard of Advent of Code, check out my [post](https://aidan-palmer.github.io/2024/12/14/aoc.html) from last year when I got really into it. This year I am going to do write-ups of each day with an explanation of the process for solving each puzzle. At least, I am going to do them until the puzzles inevitably become too hard for me at some point, which will happen a little sooner than normal since this year there will unfortunately only be 12 days of puzzles, not the usual 25. It is completely understandable that the creator of Advent of Code is burnt out and doesn't want to make so many puzzles any more, but it is still a little disapointing nevertheless. Anyways, on to the puzzles!

### [Part 1](https://adventofcode.com/2025/day/1)

As is typical of the first few days of Advent of Code, this puzzle seems pretty straightforward and easy. We're given a sequence of rotations to make on a safe's dial lock, and have to keep track of the dial's position after each rotation and count the number of times it hits 0. We'll start by parsing the input text file, which should be very easy in this case:
```c++
while (getline(file, line)) {
    char dir = line[0];
    int dist = stoi(line.substr(1));
}
```
Yes, I am doing this and all other puzzles this year in C++, the best programming language for AoC and competitive programming.
Now that we've got our data parsed, it's time to figure out the algorithm for simulating the dial rotations:
```c++
int dial = 50;
int zeros = 0;
while (getline(file, line)) {
    char dir = line[0];
    int dist = stoi(line.substr(1));
    if (dir == 'L') {
        dial -= dist;
    } else {
        dial += dist;
    }
    while (dial < 0) {
        dial += 100;
    }
    while (dial > 99) {
        dial -= 100;
    }
    if (dial == 0) {
        zeros++;
    }
}
```
This actually turned out to be a little bit tricky. I initially did not take into account rotations that were larger than 100, because there weren't any in the example, but I saw there were some large rotations in the input file, so I went from using if statements for dial < 0 and dial > 99, and changed them to while loops so that they work for larger rotations.

### Part 2

I actually really struggled with Part 2 for a while, mostly because I approached the new requirements in the wrong way. Instead of only checking when the dial points to zero after each rotation, we now have to keep track of how many times the dial crosses zero in addition to the original requirement. My mistake was not taking into account different edge cases when turning the dial left or right, and treating each turn the same regardless of direction. Turning the dial to the right is intuitively easier to keep track of, because any time you exceed 99 and go past 0 can be counted quite easily. The edge case for rotating left happens when the dial starts at 0 and rotates left and does not come back to 0, which is ultimately what took me the longest to figure out. Here is the new algorithm:

```c++
int dial = 50;
int zeros = 0;
int prev = dial;
while (getline(file, line)) {
    char dir = line[0];
    int dist = stoi(line.substr(1));
    int count = 0;
    if (dir == 'L') {
        dial -= dist;
        while (dial < 0) {
            dial += 100;
            count++;
        }
        if (dial == 0 && prev == 0) {
            count--;
        }
        if (prev == 0 && dist % 100 < 100) {
            count--;
        }
    } else {
        dial += dist;
        while (dial > 99) {
            dial -= 100;
            count++;
        }
        if (dial == 0 && count > 0) {
            count--;
        }
    }
    zeros += count;
    if (dial == 0) {
        zeros++;
    }
    prev = dial;
}
```
It may not be the most elegant algorithm, which would require much more modulo division, but it seemed the most intuitive to me, and, most importantly, it works.

My source code for Day 1 can be found [here](https://github.com/aidan-palmer/advent-of-code/tree/main/2025/Day1).