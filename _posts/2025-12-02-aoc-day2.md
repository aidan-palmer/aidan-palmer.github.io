## Advent of Code 2025 Day 2 Walkthrough

### [Part 1](https://adventofcode.com/2025/day/2)

In today's puzzle we are given a sequence of a range of integers, and need to determine which numbers within those ranges are "invalid", which in this case means that a number is made up of a sequence of digits that are repeated twice. It seems to be kind of an unusual classification, but it actually seems similar to a palindrome. Let's see if we can figure it out.

Let's start by reading in the input text:
```c++
while (getline(file, line)) {
    stringstream stream(line);
    while (getline(stream, token, ',')) {
        int dash = index_of(token, '-');
        long start = stol(token.substr(0, dash));
        long end = stol(token.substr(dash + 1));
    }
}
```

Now it's time to set up our function that will loop through the range of integers and call another function that will check if each one is invalid:
```c++
long check_ids(long start, long end) {
    long total = 0;
    for (long i = start; i <= end; i++) {
        if (is_invalid(i)) {
            total += i;
        }
    }
    return total;
}
```
I'll call that function from main with ```total += check_ids(start, end);``` to keep track of the sum of invalid ids.

Now all we have to do is figure out how to determine if an id is invalid. This is actually easier than what I thought it would be at first, and it turns out that all we have to do is check if the first half of the number is equal to the second half:
```c++
bool is_invalid(long x) {
    string s = to_string(x);
    string a = s.substr(0, s.size() / 2);
    string b = s.substr(s.size() / 2);
    return a == b;
}
```
That's it for Part 1, now let's see what Part 2 has in store for us.

### Part 2

Part 2 changes the criteria for determining if a number is invalid, specifically a number is invalid if it can be split up into 2 or more equal pieces. I used a brute force approach to this instead of trying to find a more efficient solution, mostly because I always like to try the brute force approach first, to see if it works, and in this case my program took about a minute to run on the input, which is good enough for me. These are the changes I made to the algorithm that determines if a number is invalid:
```c++
bool is_invalid(long x) {
    string s = to_string(x);
    for (size_t i = 2; i <= s.size(); i++) {
        vector<string> v;
        int n = s.size() / i;
        for (size_t j = 0; j < s.size(); j += n) {
            v.push_back(s.substr(j, n));
        }
        if (all_equal(v)) {
            return true;
        }

    }
    return false;
}
```
I essentially split the integer, in its string form, into ```i``` seperate strings of ```n``` length, then check if those strings are all equal to one another. I made another function to check if the strings are all equal:
```c++
bool all_equal(vector<string> v) {
    for (size_t i = 0; i < v.size() - 1; i++) {
        if (v[i] != v[i + 1]) {
            return false;
        }
    }
    return true;
}
```

That's it for Day 2. You can find my full source code [here](https://github.com/aidan-palmer/advent-of-code/tree/main/2025/Day2).