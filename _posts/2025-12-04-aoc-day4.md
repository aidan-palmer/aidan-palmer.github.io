## Advent of Code 2025 Day 4 Walkthrough

### [Part 1](https://adventofcode.com/2025/day/4)

For today's puzzle, we are given a grid of the characters '@' and '.' and have to determine how many '@' characters are surrounded by less than 4 other '@' characters. Seems pretty straightforward, but it will require a decent amount of programming to check all 8 adjacent characters.

Reading in our input file is very easy this time, since we need to read in the entire input into a vector of strings before we can do anything else:
```c++
while (getline(file, line)) {
    grid.push_back(line);
}
```
Now we'll need to loop through each element of the grid and call a seperate function to check if each '@' character has fewer than 4 adjacent '@' characters:
```c++
int count_rolls() {
    int total = 0;
    for (size_t i = 0; i < grid.size(); i++) {
        for (size_t j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == '@') {
                if (can_access(i, j)) {
                    total++;
                }
            }
        }
    }
    return total;
}
```
And finally we need to figure out the logic for checking the adjacent positions. There may be a more elegant way of doing this, such as matrix rotation, but I went for good old fashioned copious amounts of conditional statements:
```c++
bool can_access(int x, int y) {
    int adj = 0;
    int n = grid.size();
    int m = grid[0].size();
    if (x - 1 >= 0) {
        // Up
        if (grid[x - 1][y] == '@') {
            adj++;
        }
        // Up left
        if (y - 1 >= 0 && grid[x - 1][y - 1] == '@') {
            adj++;
        }
        // Up right
        if (y + 1 < m && grid[x - 1][y + 1] == '@') {
            adj++;
        }
    }
    if (x + 1 < n) {
        // Down
        if (grid[x + 1][y] == '@') {
            adj++;
        }
        // Down left
        if (y - 1 >= 0 && grid[x + 1][y - 1] == '@') {
            adj++;
        }
        // Down right
        if (y + 1 < m && grid[x + 1][y + 1] == '@') {
            adj++;
        }
    }
    // Left
    if (y - 1 >= 0 && grid[x][y - 1] == '@') {
        adj++;
    }
    // Right
    if (y + 1 < m && grid[x][y + 1] == '@') {
        adj++;
    }
    return adj < 4;
}
```
It may look ugly, but it works and seems to be efficient, which means I can accept its ugliness.
On to Part 2!

### Part 2

For Part 2 we need to iteratively remove all rolls of paper that have fewer than 4 neighbors until no more can be removed. We'll start by setting up the loop where we'll call ```count_rolls()``` until no more rolls can be removed:
```c++
int total = 0;
while (true) {
    int count = count_rolls();
    if (count == 0) {
        break;
    }
    total += count;
}
```
Now it's time to add in the logic to keep track of the indices where we will have to remove the rolls of paper:
```c++
int count_rolls() {
    int total = 0;
    vector<pair<int, int>> r;
    for (size_t i = 0; i < grid.size(); i++) {
        for (size_t j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == '@') {
                if (can_access(i, j)) {
                    r.push_back(make_pair(i, j));
                    total++;
                }
            }
        }
    }
    if (total > 0) {
        rm_rolls(r);
    }
    return total;
}
```
I almost made the mistake of removing the rolls within the nested for loops, but that would affect the number of adjacent rolls the following ones would have within the current iteration. So instead I made sure to keep track of the indices of the rolls to be removed and then removed them all after finding them all. Now all that's left is to "remove" the rolls by changing them from '@' to '.':
```c++
void rm_rolls(vector<pair<int, int>>& r) {
    for (pair<int, int> p : r) {
        grid[p.first][p.second] = '.';
    }
}
```

That's it for Day 4 of this year's Advent of Code. As always, you can find my full source code on my [Github](https://github.com/aidan-palmer/advent-of-code/tree/main/2025/Day4).