## Advent of Code 2025 Day 3 Walkthrough

### [Part 1](https://adventofcode.com/2025/day/3)

For today's puzzle, we are given a series of strings of digits and need to find out which combination of 2 digits can be concatenated to form the largest 2-digit integer of the string. This seems pretty straightforward in terms of a brute-force approach, so let's try the intuitive solution and see if that is efficient enough for this problem.

Let's start by parsing the input text and calling a seperate function for each string:
```c++
while (getline(file, line)) {
    total += max_jolt(line);
}
```
That's the easy part. Now we need to figure out the logic for how to find the solution. My approach is to loop through every combination of digits, and find the one that is largest:
```c++
int max_jolt(string s) {
    size_t i, j;
    string a;
    int num;
    int max = -1;
    for (i = 0; i < s.size() - 1; i++) {
        for (j = i + 1; j < s.size(); j++) {
            a = {s[i], s[j]};
            num = stoi(a);
            if (num > max) {
                max = num;
            }
        }
    }
    return max;
}
```
That's it for Part 1, let's see what Part 2 has in store for us.

### Part 2

Unfortunately, my brute force approach to Part 1 will not work for Part 2. We will have to start over with a completely different algorithm for Part 2 in order to find the largest 12-digit number instead of a 2-digit one. I figured this one out by realizing that, if we're given a string of length 15, then our first digit cannot be past index 3 in order to get a string of length 12. Figuring out how to actually implement that logic was very difficult, and I made many small mistakes and incrementally fixed them until I got this function:
```c++
long max_jolt(string s) {
    string jolt;
    size_t i = 0, j;
    int max, max_idx, x;
    size_t skipped = 0;
    while (skipped < s.size() - 12 && jolt.size() != 12) {
        max = -1;
        max_idx = -1;
        for (j = i; j < i + (s.size() - 12) - skipped + 1; j++) {
            x = ctoi(s[j]);
            if (x > max) {
                max = x;
                max_idx = j;
            }
        }
        skipped += max_idx - i;
        i = max_idx + 1;
        jolt.push_back(s[max_idx]);
    }
    if (jolt.size() < 12) {
        jolt += s.substr(i, 12 - jolt.size());
    }
    return stol(jolt);
}
```
I think you could call this a greedy algorithm, or maybe it would be called something else. Either way, it works and is efficient, which is what matters.

You can find my full source code [here](https://github.com/aidan-palmer/advent-of-code/tree/main/2025/Day3).